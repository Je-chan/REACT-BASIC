# 반응형 Effect 의 생명주기

- Effect 는 컴포넌트와 다른 생명주기를 갖는다.
- 컴포넌트는 마운트, 업데이트, 마운트 해제. 이렇게 세 단계가 있다
- Effect 는 동기화릋 시작하고 나중에 동기화를 중지하는 두 가지 작업만 할 수 있다.

## 1. Effect 의 생명주기

- 모든 React 의 컴포넌트는 동일한 생명주기를 갖는다.

1. 컴포넌트는 화면에 추가될 때 마운트한다.
2. 컴포넌트는 새로운 props 나 state 를 받으면 업데이트 한다
3. 화면에서 제거되면 컴포넌트는 마운트 해제된다

- 그러나 이런 생각을 Effect 에 적용할 수는 없다.
- 각 Effect 를 컴포넌트의 생명주기와 독립적으로 생각해야 한다.
  - Effect 는 외부 시스템을 현재 props 및 state 에 동기화하는 방법을 설명한다.
  - 코드가 변경되면 이 동기화를 더 자주 또는 덜 자주 수행해야 한다.
- 직관적으로 React 는 컴포넌트가 마운트될 때 동기화를 시작하고 컴포넌트가 마운트 해제될 때 동기화를 중지할 것이라 생객하지만 어떤 경우 컴포넌트가 마운트된 상태에서 동기화를 여러 번 시작하고 중지해야할 수 있다.

### 1-1) 각각의 Effect 는 별도의 동기화 프로세스를 나타낸다.

- 코드의 각 Effect 는 별도의 독립적인 동기화 프로세스를 나타내야 한다
- 일관된 로직을 별도의 Effect 로 분리하면 코드가 더 깔끔해 보일 수 있겠지만 유지관리가 더 어려워진다.
- 코드가 더 깔끔해 보이는지의 여부보다는 프로세스가 동일한지, 혹은 분리돼 있는지를 고려해야 한다.

## 2. Effect 는 반응형 값에 반응한다.

- 컴포넌트 내부에서 선언된 props, state 및 기타 값은 렌더링 중에 계산되고 React 데이터 흐름에 참여하기에 반응형이다.

### 2-1) 빈 의존성을 가지고 있는 Effect 의 의미

- 컴포넌트의 관점에서 생각해보면 빈 의존성 배열은 Effect 가 컴포넌트가 마운트될 때만 채팅방에 연결되고 컴포넌트가 마운트 해제될 때만 연결이 끊어진다는 것을 읨한다.
- 하지만, Effect 관점에서 생각해보면 마운트나 마운트 해제 등에 대해서 생각할 필요가 없다
- 중요한 것은 Effect 가 동기화를 시작하고 중지하는 작업을 지정하는 것이다.

### 2-2) 컴포넌트 본문에서 선언된 모든 변수는 반응형이다

- props 와 state 만 반응형 값인 것은 아니다
- 이들로부터 계산하는 값들 모두 반응형이다.
  - props 나 state 가 변경되면 컴포넌트가 다시 렌더링되고 그로부터 계산된 값도 변경된다.
  - 그렇기에 Effect 가 사용하는 컴포넌트 본문의 모든 변수는 Effect 의존성 목록에 있어야 한다.
- 컴포넌트 내부의 모든 값은 반응형이다.
- 모든 반응형 값은 다시 렌더링할 때 변경될 수 있으므로 반응형 값을 Effect 의 의존성으로 포함시켜야 한다.

그러나 전역 변수와 변이 가능한 값은 반응하지 않는다.

- location.pathname 과 같은 Mutation 이 가능한 값은 의존성이 될 수 없다.
  - 변이가 가능한 값은 React 렌더링 데이터 흐름 외부에서 언제든 바뀔 수 있다.
  - 이 값을 변경해도 컴포넌트가 다시 렌더링되지 않는다.
  - 따라서 이를 의존성에 지정하더라도 Effect 가 다시 동기화해야하는지 알 수없다
  - 이런 값들은 useSyncExternalStore 를 사용해서 외부 변경 가능한 값을 읽고 구독해야 한다.
- ref.current 와 같이 변이 가능한 값 도는 이 값으로부터 읽은 것 역시 의존성이 될 수 없다

### 2-3) React 는 모든 반응형 값을 의존성으로 지정했는지 검토한다.

- 린터가 React 에 맞게 구성된 경우, Effect 코드에서 사용되는 모든 반응형 값이 해당 의존성으로 선언됐는지 확인한다.
- 이는 React 오류처럼 보일 수 있지만 실제로는 코드의 버그를 지적하는 것이다.
- 버그를 수정하기 위해서는 린터의 제안에 따라 의존성 요소로 빠진 반응형 값을 넣어주면 된다.

### 2-4) 재 동기화를 원하지 않는 경우

- Effect 는 반응형 코드 블록이다.
- 내부에서 읽은 값이 변경되면 다시 동기화된다. 상호작용당 한 번만 실행되는 이벤트 핸들러와 달리 Effect 는 동기화가 필요할 때마다 실행된다.
- 의존성을 “선택할 수 없다”
  - 의존성에는 Effect 에서 읽은 모든 반응형 값이 포함돼야 한다.
  - 린터는 이를 강제한다.
  - 린터를 억제해서 이런 문제를 해결해서는 안된다.
- 만약, 반응형값을 빼고 싶은 경우, 다음의 방법을 시도해볼 숭수 있다.

1. Effect 가 독립적인 동기화 프로세스를 나타내는지 확인할 것
   - Effect 가 아무것도 동기화하지 않으면 불필요한 것일 수 있다.
   - 여러 개의 독립적인 것을 동기화하는 경우 분할해야 한다.
2. 반응하지 않고 Effect 를 재동기화하지 않으면서 props 나 state 의 최신 값을 읽으려면 Effect 를 반응하는 부분과 반응하지 않는 부분으로 분리할 수 있어야 한다.
   - 이는 이벤트와 Effect 를 분리하는 방법으로 사용할 수 있다.
3. 객체나 함수를 의존성으로 사용하지 말 것
   - 렌더링 중에 오브젝트와 함수를 생성한 다음 Effect 에서 읽으면 렌더링할 때마다 오브젝트와 함수가 달라진다.
