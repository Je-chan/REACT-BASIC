# Effect 와 동기화하기
## 1. Effect란 무엇이며, 이벤트와 어떤 것이 다른가?

- Effect 에 도달하기 전, React 컴포넌트 내부의 두 가지 유형의 논리에 익숙해져야 한다.

### 렌더링 코드

- 컴포넌트의 최상위 레벨에 있다.
- 여기서 props 와 state 를 가져와 변환하고 화면에 표시할 JSX 를 반환한다.
- 렌더링 코드는 순수해야 한다.

### 이벤트 핸들러

- 컴포넌트 내부에 있는 중첩된 함수
- 계산만 하는 것이 아니라 별도의 작업도 수행한다.
- 이벤트 핸들러에서는 입력 필드를 업데이트 하거나, HTTP 요청을 하는 것 등의 일을 할 수 있다.
- 이벤트 핸들러에는 특정 사용자의 작업으로 인해 발생하는 사이드 이펙트(state 변경)가 포함돼 있다.

- Effect 를 사용하면 특정 이벤트가 아닌 렌더링 자체로 인해 발생하는 사이드 이펙트를 명시할 수 있다.
	- 채팅에서 메시지를 보내는 것은 사용자가 입력하고 클릭하기 때문에 발생하는 이벤트
	- 하지만 서버 연결을 설정하는 것은 컴포넌트를 표시하게 만든 상호 작용에 관계 없이 발생
	- Effect 는 화면 업데이트 후 커밋이 끝날 때 실행된다
	- 이 때, React 컴포넌트를 일부 외부 시스템(네트워크, 혹은 서드파티 라이브러리)과 동기화해야 한다.

## 2. Effect 가 필요하지 않을 수도 있다.

- 컴포넌트에서 무작정 Effect 를 추가하려고 해서는 안 된다.
- Effect 는 일반적으로 React 코드에서 벗어나 일부 외부 시스템과 동기화하기 위해 사용된다.
	- 브라우저 API, 서드파티 위젯, 네트워크 등
- Effect 가 다른 state 기반으로 일부 state 만을 조정하는 경우, Effect 가 필요하지 않을 수 있다.

## 3. Effect 작성 방법

- Effect 를 작성하기 위해서는 세 단계를 따라야 한다

1. Effect 선언
2. Effect 의 의존성을 명시
3. 필요한 경우 클린업 추가

### Step 1 : Effect 선언

- 컴포넌트에 Effect 를 선언하기 위해서 React 에서 useEffect Hook 을 import gksek.
- 컴포넌트 최상위 레벨에서 호출하고, Effect 내부에 코드를 추가한다.
- 컴포넌트가 렌더링될 때마다, React 는 화면을 업데이트하고, useEffect 내부의 코드를 실행한다
	- 즉, useEffect 는 해당 렌더링이 화면에 반영될 때까지 코드 조각의 실행을 지연한다

### Step 2 : Effect 의존성을 명시

- 기본적으로 Effect 는 매번 렌더링 후에 실행된다.
- 하지만 다음의 이유로 매번 렌더링을 지양해야 한다
	1. 속도가 느릴 수 있다.
		- 외부 시스템과의 동기화가 항상 즉각적인 것은 아니다.
		- 꼭 필요한 경우가 아니라면 동기화를 건너뛰는 것이 좋다
	2. 잘못된 경우가 있다
		- 키 입력시마다 컴포넌트 페이드인 애니메이션을 발동시키고 싶지 않을 수 있다.
- 이 문제를 해결하는 방법은 useEffect 에서 두 번째 인자로 의존성 배열을 추가하는 것이다.
- 의존성 배열은 여러 의존성을 포함시킬 수 있다.
	- React 는 지정한 의존성의 값이 이전 렌더링 때와 정확히 동일한 경우에만 Effect 의 재실행을 건너뛴다.
	- React 는 [Object.is](http://Object.is) 비교를 사용해 의존성 값을 비교한다. (즉, 주소값을 비교하는 것)
- 의존성은 선택할 수 없다. 지정한 의존성들이 Effect 내부 코드를 기반으로 React 가 예상하는 것과 일치하지 않으면 lint 오류를 발생시킨다.
- 의존성에 ref 가 들어가지 않는 이유는, ref 는 항상 [Object.is](http://Object.is) 가 true 값으로 나오기 때문에 의존성 배열로 추가한들, useEffect 가 실행되지 않는다

### Step 3 : 필요한 경우 클린업 추가

- React 는 Effect 가 다시 실행되기 전에 매번 클린업 함수를 호출하고, 컴포넌트가 마운트 해제될 때 마지막으로 한 번 더 호출한다.